/*有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置（上、下、左、右）的灯都会改变一次。即，如果灯原来是点亮/熄灭的，就会被熄灭/点亮。
在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。
在图1中，左边矩阵中用Ⅹ标记的按钮表示被按下，右边矩阵表示灯状态的改变。
与一盏灯毗邻的多个按钮被按下时，一次操作会抵消另一次操作的结果。如图2所示。
在图2中，第2行第2、3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。
输入样例：
2 
0 1 1 0 1 0
1 0 0 1 1 1 
0 0 1 0 0 1 
1 0 0 1 0 1 
0 1 1 1 0 0 
0 0 1 0 1 0 
1 0 1 0 1 1 
0 0 1 0 1 1 
1 0 1 1 0 0 
0 1 0 1 0 0
输出样例：
PUZZLE #1
1 0 1 0 0 1 
1 1 0 1 0 1 
0 0 1 0 1 1 
1 0 0 1 0 0 
0 1 0 0 0 0
PUZZLE #2
1 0 0 1 1 1 
1 1 0 0 0 0 
0 0 0 1 0 0 
1 1 0 1 0 1 
1 0 1 1 0 1
*/
#include<iostream>
using namespace std;
int a[7][8];
int b[7][8];
//judge is or not
bool judge()
{
    int i,j;
for(i=2;i<7;i++)
   for(j=1;j<7;j++)
       b[i][j]=(a[i-1][j]+b[i-1][j-1]+b[i-1][j]+b[i-1][j+1]+b[i-2][j])%2;
   for(j=1;j<7;j++)
       if(b[6][j])return false;
       return  true;
}
int main()
{
    int n,k=0,i,j;
    scanf("%d",&n);
    while(k)
    {
        //inpput
        for(i=1;i<6;i++)
            for(j=1;j<7;j++)
                scanf("%d",&a[i][j]);
            for(i=0;i<64;i++)
            {
                int t=i;
                for(j=6;j>=1;j--)
                {
                    b[1][j]=t%2;
                    t/=2;
                }
                if(judge())
                    break;
            }
            //output
            printf("PUZZLE #%d\n",++k);
            for(i=1;i<6;i++){
            for(j=1;j<7;j++)
                printf("%d ",b[i][j]);
               cout<<endl;
            }
           

    }
    return 0;
}
